#include <windows.h>
#include <mex.h>
#include <matrix.h>

#include "eigen3/Eigen/Core"
#include "eigen3/Eigen/LU"
#include "eigen3/Eigen/Eigenvalues"

#include <iostream>

using Eigen::Matrix;
using Eigen::Map;
using Eigen::EigenSolver;
using Eigen::MatrixXd;

//mxArray *AA = mxCreateDoubleMatrix(9, 9, mxREAL);

void computeCoefficients1x10(double altitude, double imageCoordinates, const
	double in3[20], const double in4[20], double output[10])
{
	double t2;

	/* COMPUTECOEFFICIENTS1X10 */
	/*     OUTPUT = COMPUTECOEFFICIENTS1X10(ALTITUDE,IMAGECOORDINATES,IN3,IN4) */
	/*     This function was generated by the Symbolic Math Toolbox version 6.1. */
	/*     27-Dec-2014 17:53:03 */
	t2 = altitude * altitude;
	output[0] = in3[15] - in4[15] * imageCoordinates;
	output[1] = in3[12] - in4[12] * imageCoordinates;
	output[2] = in3[14] - in4[14] * imageCoordinates;
	output[3] = in3[11] - in4[11] * imageCoordinates;
	output[4] = (in3[8] + altitude * in3[18]) - imageCoordinates * (in4[8] +
		altitude * in4[18]);
	output[5] = (in3[4] + altitude * in3[10]) - imageCoordinates * (in4[4] +
		altitude * in4[10]);
	output[6] = (in3[7] + altitude * in3[17]) - imageCoordinates * (in4[7] +
		altitude * in4[17]);
	output[7] = ((in3[2] + altitude * in3[6]) + in3[16] * t2) - imageCoordinates *
		((in4[2] + altitude * in4[6]) + in4[16] * t2);
	output[8] = ((in3[1] + altitude * in3[5]) + in3[13] * t2) - imageCoordinates *
		((in4[1] + altitude * in4[5]) + in4[13] * t2);
	output[9] = (((in3[0] + altitude * in3[3]) + in3[9] * t2) - imageCoordinates *
		(((in4[0] + altitude * in4[3]) + in4[9] * t2) + altitude * in4[19]
		* t2)) + altitude * in3[19] * t2;
}


void constructionFinalMatrix(const Matrix<double, 10, 2> &coefficients, Matrix<double, 21, 12> &finalMatrix){

	int poly_multiply_1[10] = { 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };
	int poly_multiply_latitude[10] = {6, 7, 8, 9, 11, 12, 13, 15, 16, 18};
	int poly_multiply_longtitude[10] = {7, 8, 9, 10, 12, 13, 14, 16, 17, 19};
	int poly_multiply_longtitude_longtitude[10] = {2, 3, 4, 5, 8, 9, 10, 13, 14, 17 };
	int poly_multiply_latitude_longtitude[10] = {1, 2, 3, 4, 7, 8, 9, 12, 13, 16};
	int poly_multiply_latitude_latitude[10] = {0, 1, 2, 3, 6, 7, 8, 11, 12, 15};

	int *poly_multiply[] = { poly_multiply_1, poly_multiply_latitude, poly_multiply_longtitude, 
		poly_multiply_longtitude_longtitude, poly_multiply_latitude_longtitude, poly_multiply_latitude_latitude};

	// compute final matrix
	int colIdx = 0;
	for (int i = 0; i < 6; ++i){
		for (int j = 0; j < 10; ++j){
			finalMatrix(poly_multiply[i][j], colIdx ) = coefficients(j, 0);
			finalMatrix(poly_multiply[i][j], colIdx + 1) = coefficients(j, 1);
		}
		colIdx += 2;
	}

	// compute echelon form of the final matrix	
	Eigen::PermutationMatrix<21> perm; perm.setIdentity();
	perm.applyTranspositionOnTheRight(10,11);
	perm.applyTranspositionOnTheRight(11,12);	
	finalMatrix = (finalMatrix.transpose() * perm).transpose();
	Eigen::FullPivLU<MatrixXd> lu_12_12(finalMatrix.topRows(12).transpose());
	finalMatrix = (lu_12_12.solve(finalMatrix.transpose())).transpose();
	finalMatrix = (finalMatrix.transpose() * perm.inverse()).transpose();
}

void constructionActionMatrix(const Matrix<double, 21, 12> &finalMatrix, Matrix<double, 9, 9> &actionMatrix){

	actionMatrix(2, 0) = 1.0;
	actionMatrix(4, 1) = 1.0;
	actionMatrix(5, 2) = 1.0;
	actionMatrix(6, 4) = 1.0;
	actionMatrix(7, 5) = 1.0;
	actionMatrix(8, 7) = 1.0;

	int col_ids_finalmatrix_for_action_matrix[9] = { 10, 13, 14, 15, 16, 17, 18, 19, 20 };
	int row_ids_finalmatrix_for_action_matrix[3] = { 5, 9, 11};
	int row_ids_in_action_matrix[3] = { 0, 1, 3 };

	for (int i = 0; i < 3; ++i){
		for (int j = 0; j < 9; ++j){
			//actionMatrix(i, j) = -finalMatrix.transpose()(row_ids_finalmatrix_for_action_matrix[i], col_ids_finalmatrix_for_action_matrix[j]);
			actionMatrix(row_ids_in_action_matrix[i], j) = -finalMatrix(col_ids_finalmatrix_for_action_matrix[j], row_ids_finalmatrix_for_action_matrix[i]);
		}
	}
}

//void computePosition(const Matrix<double, 9, 9> &actionMatrix, double &latitude, double &longtitude){
int computePosition(const Matrix<double, 9, 9> &actionMatrix, double pos[2*9]){

	const EigenSolver<MatrixXd> eigen_solver(actionMatrix);
	const EigenSolver<MatrixXd>::EigenvectorsType &eigen_vectors = eigen_solver.eigenvectors();
	const EigenSolver<MatrixXd>::EigenvalueType &eigen_values = eigen_solver.eigenvalues();
	int numOfSolutions = 0;
	for (int i = 0; i < eigen_vectors.cols(); ++i)	{
		if (eigen_values[i].imag() == 0) {	// real solutions
			Matrix<double, 9, 1> eigen_vector = eigen_vectors.col(i).real();

			Eigen::Vector2d result = eigen_vector.middleRows<2>(6) / eigen_vector(8);
			//if (result(0) >= -1.0 &&  result(0) <= 1.0 && result(1) >= -1.0 &&  result(1) <= 1.0){
			//	latitude = result(0);
			//	longtitude = result(1);
				//return;
			//}
			pos[numOfSolutions * 2 + 0] = result(0);
			pos[numOfSolutions * 2 + 1] = result(1);
			numOfSolutions++;
		}
	}
	std::cout << "Warning: no valid inverse mapping found\n" << std::endl;
	//latitude = 0.0;
	//longtitude = 0.0;
	return numOfSolutions;
}

//void inverseMapping(const double coeffs1[20], const double coeffs2[20], const double coeffs3[20], const double coeffs4[20], const double imageCoordinates[2], 
//	const double altitude, double &latitude, double &longtitude){
int inverseMapping(const double coeffs1[20], const double coeffs2[20], const double coeffs3[20], const double coeffs4[20], const double imageCoordinates[2], 
	const double altitude, double pos[2*9]){


	Matrix<double, 10, 2> coefficients;

	computeCoefficients1x10(altitude, imageCoordinates[0], coeffs1, coeffs2, coefficients.col(0).data());
	computeCoefficients1x10(altitude, imageCoordinates[1], coeffs3, coeffs4, coefficients.col(1).data());

	//std::cout << coefficients << std::endl;
	//printf("hello world %0.10f,%0.10f \n", coefficients(0, 0), coefficients(1,0));
	
	// do the multiplications and also remove unnecessary polynomials and monomials, and put in a new matrix
	Matrix<double, 21, 12> finalMatrix = Matrix<double,21,12>::Zero();
	constructionFinalMatrix(coefficients, finalMatrix);

	//double *data = mxGetPr(AA);
	//memcpy(data, finalMatrix.data(), 21 * 12 * sizeof(double));

	// find the action matrix
	Matrix<double, 9, 9> actionMatrix = Matrix<double, 9, 9>::Zero();
	constructionActionMatrix(finalMatrix, actionMatrix);

	//double *data = mxGetPr(AA);
	//memcpy(data, actionMatrix.data(), 9 * 9 * sizeof(double));
	// solve the action matrix to get results

	int numOfSolutions = computePosition(actionMatrix, pos);
	return numOfSolutions;
}

double PCFreq = 0.0;
__int64 CounterStart = 0;

void StartCounter()
{
	LARGE_INTEGER li;
	
	PCFreq = double(li.QuadPart) / 1000.0;

	QueryPerformanceCounter(&li);
	CounterStart = li.QuadPart;
}
double GetCounter()
{
	LARGE_INTEGER li;
	QueryPerformanceCounter(&li);
	return double(li.QuadPart - CounterStart) / PCFreq;
}

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[]){

	double *coeffs1 = mxGetPr(prhs[0]);
	double *coeffs2 = mxGetPr(prhs[1]);
	double *coeffs3 = mxGetPr(prhs[2]);
	double *coeffs4 = mxGetPr(prhs[3]);
	double *imageCoordinates = mxGetPr(prhs[4]);
	double *altitude = mxGetPr(prhs[5]);

	mxArray *AA = mxCreateDoubleMatrix(2, 10, mxREAL);
	double *pos = mxGetPr(AA);
	plhs[0] = AA;
	//double pos[2];
	
	//StartCounter();
	//int numOfSolutions = inverseMapping(coeffs1, coeffs2, coeffs3, coeffs4, imageCoordinates, *altitude, pos[0], pos[1]);
	int numOfSolutions = inverseMapping(coeffs1, coeffs2, coeffs3, coeffs4, imageCoordinates, *altitude, pos);
	pos[9*2] = numOfSolutions;

	//double t = GetCounter();
	//printf( "timing: %f\n",  t );
	

}
